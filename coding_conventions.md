Penny Vision Project - Coding ConventionsStandardized guidelines for all project scripts and modules to ensure consistency, readability, and maintainability.1. Project Structure & Python VersionProject Root: The root directory is the one containing penny_ai, src, configs, data, etc. All relative paths in configurations and scripts should generally be considered relative to this root.Main Application Code:Core application logic and reusable modules should reside primarily within the penny_ai/ directory.Specialized scripts, such as data processing or model training entry points, can be in scripts/ or src/model_training/.Python Version: This project targets Python 3.11.9. Code should be compatible with this version.2. File and Module LayoutFilenames: Use snake_case for Python files (e.g., extract_rois.py, penny_classifier.py). Avoid spaces or hyphens.Module Structure: Each Python module (.py file) should begin with a module header block.3. Module HeaderPlace the following block at the top of each .py file:# filename.py
# Purpose: Concise one-sentence summary of the module's primary functionality.
# Author: <Your Name> or Team Name
# Created: YYYY-MM-DD
# Last Modified: YYYY-MM-DD
# Version: X.Y.Z (Optional for internal modules; use Git tags for releases)
# Dependencies: Key third-party libraries directly imported and used in this module (for quick reference).
#               (Project-level dependencies are managed in requirements.txt or pyproject.toml)
Created/Last Modified: Helps track the module's history.Version: Optional for individual files; primary versioning is through Git tags. If used, update for significant changes to the module's interface or core logic.4. DocstringsStyle: Use Google-style or NumPy-style docstrings consistently for all public modules, functions, classes, and methods.Google-style Example:def my_function(arg1: str, arg2: int) -> bool:
    """Summarizes what the function does.

    Extended description if necessary.

    Args:
        arg1 (str): Description of arg1.
        arg2 (int): Description of arg2.

    Returns:
        bool: Description of the return value.

    Raises:
        ValueError: If arg2 is negative.
    """
    if arg2 < 0:
        raise ValueError("arg2 cannot be negative")
    return True
Content: Docstrings must clearly explain the purpose, arguments (Args:), return values (Returns:), and any exceptions raised (Raises:).Classes: Class docstrings should describe the class. The __init__ method should have its own docstring describing its parameters.5. Naming Conventions (PEP 8)Modules: lowercase_with_underscores (e.g., image_utils.py)Packages: short_lowercase (e.g., penny_ai, model_training)Classes: PascalCase (or CapWords) (e.g., PennyClassifier, DataAugmentation)Functions & Methods: lowercase_with_underscores (e.g., detect_mint_mark(), _private_helper())Variables: lowercase_with_underscores (e.g., penny_image, detection_threshold)Constants: UPPER_SNAKE_CASE (e.g., MIN_CONTRAST = 0.1, DEFAULT_BATCH_SIZE = 32).Define constants at the module level or class level where appropriate. Avoid magic numbers/strings in code; use named constants.6. ImportsStandard library imports (e.g., import os, from pathlib import Path)Third-party library imports (e.g., import numpy as np, import torch)Local application/library specific imports (project's own modules):Use absolute imports based on the project structure. Assuming the project root is in PYTHONPATH or you are running scripts from the root:from penny_ai.utils import image_processingfrom src.model_training import trainerFor imports within the same package (e.g., inside penny_ai), relative imports (from . import sibling_module, from ..parent_module import something) can be used but use them judiciously.Grouping: Separate each group of imports with a single blank line.Avoid from module import *: This can pollute the namespace and make code harder to understand.Order: Within each group, imports should generally be sorted alphabetically.7. Logging & Error HandlingLogging Module: Use the standard logging module for all informational messages, warnings, and errors.Module-Level Logger: Instantiate a logger at the module level:import logging
logger = logging.getLogger(__name__)
Configuration: Logging should be configured centrally (e.g., in your main application script or a dedicated logging setup module), defining handlers, formatters, and levels.Exception Handling:Avoid bare except: clauses. Always catch specific exceptions (e.g., except FileNotFoundError:, except ValueError:).If re-raising an exception, consider adding context or wrapping it in a custom project-specific exception if it aids in debugging or provides more semantic meaning.Use try...finally blocks for cleanup operations that must always occur.8. Formatting, Linting, and Static AnalysisPEP 8: Code must adhere to PEP 8 style guidelines.Formatter: Use Black for automatic code formatting.Configure Black for a maximum line length of 88 characters.Linter: Use Flake8 for linting (checks PEP 8, logical errors, complexity).Type Checking: Use Mypy for static type checking.Automation:Pre-commit Hooks: Strongly recommended. Configure pre-commit hooks (e.g., using the pre-commit framework) to run Black, Flake8, and Mypy automatically before each commit. This ensures that only clean, formatted, and type-checked code is committed.CI/CD: Integrate these checks into your CI/CD pipeline (e.g., GitHub Actions defined in .github/workflows/) to enforce conventions on all contributions.Commit Policy: Only commit code that passes all linting and type checks.9. Type Hints (PEP 484)Annotation: Annotate all public functions, methods (including __init__), and class attributes with type hints.Clarity: Extend type hints to private functions/methods and local variables where it significantly improves code clarity and helps Mypy.Goal: Aim for code that passes mypy --strict where feasible, or at least a well-defined subset of Mypy checks.Complex Types: Use the typing module for complex types (e.g., List, Dict, Tuple, Optional, Callable, Any).10. Configuration and PathsCentralized Configuration:Project configurations (paths, hyperparameters, model settings) are primarily managed through YAML files in the configs/ directory (e.g., training_config.yaml). This approach minimizes the need for command-line arguments for script execution.Code should load configurations from these YAML files using libraries like PyYAML.Path Management:YAML Paths: Paths defined in YAML configuration files (e.g., data_root: "./data") are typically relative to the project root.Code Paths:When loading paths from YAML, ensure they are resolved correctly, usually by constructing absolute paths from the project root.Use pathlib.Path for all file system path manipulations.from pathlib import Path
import yaml

PROJECT_ROOT = Path(__file__).resolve().parent.parent # Adjust if this script is nested deeper

def load_config(config_name: str = "training_config.yaml") -> dict:
    config_path = PROJECT_ROOT / "configs" / config_name
    with open(config_path, 'r') as f:
        config = yaml.safe_load(f)
    return config

config = load_config()
data_root_path = PROJECT_ROOT / config['paths']['data_root']
# Now use data_root_path
Avoid Hardcoded Paths: Do not hardcode absolute paths or overly complex relative paths directly in the code. Rely on configuration files and robust path construction.Constants vs. Config:Truly immutable, universal constants (e.g., mathematical constants, fixed labels if not part of a dataset definition) can be defined as UPPER_SNAKE_CASE in relevant modules.Parameters that might change between experiments, deployments, or datasets should be in configuration files.11. Testing (Simplified Approach for Solo Development)Importance: While comprehensive automated testing is a best practice for larger teams and long-term projects, for solo rapid development, a more streamlined approach can be taken.Manual & Exploratory Testing: Focus on thorough manual testing of key functionalities and exploratory testing during development to catch obvious issues.Minimal Unit Tests (Optional): If time permits, consider writing basic unit tests for highly critical or complex utility functions that are prone to errors or have well-defined inputs/outputs.The tests/ directory and pytest framework can be used if you decide to implement some tests.Your training_config.yaml includes test_paths which can be leveraged if/when testing is introduced.Focus: Prioritize developing core features and iterate quickly. Formal testing can be scaled up if the project grows or requires higher reliability guarantees in the future.12. Version Control (Git)Commit Messages: Write clear, concise, and descriptive commit messages. Follow conventional commit formats if the team agrees (e.g., feat: add penny orientation model, fix: resolve issue with mint mark ROI).Branching Strategy: Adopt a consistent branching strategy (e.g., GitFlow, feature branches like feature/add-date-classifier, fix/improve-detection-accuracy). Main/master branch should always be stable.Atomic Commits: Each commit should represent a single logical change.Tagging:Tag commits that correspond to new model releases or significant software versions (e.g., v0.1.0, model-side-v1.2).Use semantic versioning (e.g., MAJOR.MINOR.PATCH) for software releases..gitignore: Maintain a comprehensive .gitignore file to exclude virtual environments (.venv/, penny_ai/.venv/), cache files (.pytest_cache/, __pycache__/), IDE-specific files, OS-specific files, and large data/output files not intended for version control. Your output/ and parts of data/ (like raw_images/iCloud Photos) might be candidates for .gitignore if very large, relying on external storage or generation scripts.13. Environment ManagementVirtual Environments: All development must be done within a dedicated Python virtual environment (e.g., using venv as indicated by penny_ai/.venv/).Dependency Management:Maintain a requirements.txt file (generated via pip freeze > requirements.txt) or use a more advanced tool like Poetry or PDM with a pyproject.toml file to manage project dependencies.Keep dependencies updated and specify versions to ensure reproducible builds.14. General Code QualityReadability: Prioritize writing clear, readable, and understandable code.Simplicity (KISS): Keep It Simple, Stupid. Avoid overly complex solutions where simpler ones suffice.Don't Repeat Yourself (DRY): Encapsulate reusable logic into functions or classes.Comments: Write comments to explain why code is written a certain way if it's not obvious, or to clarify complex logic. Avoid commenting on what the code is doing if it's self-evident.Refactoring: Regularly refactor code to improve its structure, readability, and performance as the project evolves.This document should be considered a living document and may be updated as the project evolves and new best practices are identified.